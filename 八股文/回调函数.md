 ref：[10张图让你彻底理解回调函数-CSDN博客](https://blog.csdn.net/2401_83384536/article/details/139172825)
#### 理解
**回调函数是指一段以参数的形式传递给其它代码的可执行代码。**

对于一般的函数来说，我们自己编写的函数会在自己的程序内部调用，也就是说函数的编写方是我们自己，调用方也是我们自己。

但回调函数不是这样的，虽然函数编写方是我们自己，但是函数调用方不是我们，而是我们引用的其它模块，也就是第三方库，我们调用第三方库中的函数，并把回调函数传递给第三方库，第三方库中的函数调用我们编写的回调函数
之所以需要给第三方库指定回调函数，是因为第三方库的编写者并不清楚在某些特定节点
另一点值得注意的是，从图中我们可以看出回调函数和我们的主程序位于同一层中，我们只负责编写该回调函数，但并不是我们来调用的。

最后值得注意的一点就是回调函数被调用的时间节点，回调函数只在某些特定的节点被调用，就像上面说的油条制作完成、接收到网络数据、文件读取完成等，这些都是事件，也就是event，本质上我们编写的回调函数就是用来处理event的，因此从这个角度看回调函数不过就是event handler，因此回调函数天然适用于事件驱动编程event-driven，我们将会在后续文章中再次回到这一主题。

![[回调函数.png]]

#### **回调的类型**
区别在于回调函数被调用的时机
##### **同步回调**
这种回调就是通常所说的同步回调synchronous callbacks、也有的将其称为阻塞式回调blocking callbacks，或者什么修饰都没有，就是回调，callback，这是我们最为熟悉的回调方式。

当我们调用某个函数A并以参数的形式传入回调函数后，在A返回之前回调函数会被执行，也就是说我们的主程序会等待回调函数执行完成，这就是所谓的同步回调。
![[同步回调.png]]


##### 异步回调
不同于同步回调， 当我们调用某个函数A并以参数的形式传入回调函数后，A函数会立刻返回，也就是说函数A并不会阻塞我们的主程序，一段时间后回调函数开始被执行，此时我们的主程序可能在忙其它任务，回调函数的执行和我们主程序的运行同时进行。

既然我们的主程序和回调函数的执行可以同时发生，因此一般情况下，主程序和回调函数的执行位于不同的线程或者进程中。
![[异步回调.png]]

#### 回调对应的编程思维模式
让我们用简单的几句话来总结一下回调下与常规编程思维模式的不同。
假设我们想处理某项任务，这项任务需要依赖某项服务S，我们可以将任务的处理分为两部分，调用服务S前的部分PA，和调用服务S后的部分PB。
在常规模式下，PA和PB都是服务调用方来执行的，也就是我们自己来执行PA部分，等待服务S返回后再执行PB部分。
但在回调这种方式下就不一样了。
在这种情况下，我们自己来执行PA部分，然后告诉服务S：“等你完成服务后执行PB部分”。
因此我们可以看到，现在一项任务是由不同的模块来协作完成的。
即：
常规模式：调用完S服务后后我去执行X任务，
回调模式：调用完S服务后你接着再去执行X任务，
其中X是服务调用方制定的，区别在于谁来执行。

#### 为什么异步回调越来越重要

在同步模式下，服务调用方会因服务执行而被阻塞暂停执行，这会导致整个线程被阻塞，因此这种编程方式天然不适用于高并发动辄几万几十万的并发连接场景，
针对高并发这一场景，异步其实是更加高效的，原因很简单，你不需要在原地等待，因此从而更好的利用机器资源，而回调函数又是异步下不可或缺的一种机制。


#### 基本定义
回调函数（Callback Function）是一种**编程模式**，它允许一个函数（称为"高阶函数"或"调用函数"）在特定时刻调用另一个函数（称为"回调函数"）。回调的本质是**将函数作为参数传递给另一个函数**，并在需要时由接收方执行该函数。

#### 核心概念：

1. **函数作为参数**：回调函数被作为参数传递给另一个函数
2. **延迟执行**：回调函数不会立即执行，而是在特定条件满足或事件发生时被调用
3. **控制反转**：调用方决定何时执行回调函数，而不是被调用方
4. **解耦机制**：调用方和回调方不需要直接了解对方的实现细节
```
// 回调函数的基本结构
void callbackFunction(int result) {
    std::cout << "处理结果: " << result << std::endl;
}

// 接收回调的高阶函数
void processData(int a, int b, void (*callback)(int)) {
    int result = a * b; // 执行计算
    callback(result);   // 执行回调函数
}

int main() {
    // 将回调函数作为参数传递
    processData(5, 4, callbackFunction);
    // 输出: 处理结果: 20
}
```
#### 回调函数的实现机制

##### 在C++中实现回调的常用方法：
1. **函数指针**（传统C风格）：
```
// 定义回调函数类型
typedef void (*DataCallback)(const std::string&);

// 使用回调的函数
void fetchData(DataCallback callback) {
    std::string data = "从服务器获取的数据";
    callback(data); // 执行回调
}

// 回调函数实现
void handleData(const std::string& data) {
    std::cout << "处理数据: " << data << std::endl;
}

int main() {
    fetchData(handleData);
}
```
2. **`std::function`**（现代C++推荐）：
```
#include <functional>
#include <iostream>

// 使用std::function定义回调类型
void processUserInput(std::function<void(int)> callback) {
    int input;
    std::cout << "请输入数字: ";
    std::cin >> input;
    callback(input); // 执行回调
}

int main() {
    processUserInput([](int value) { // 使用Lambda表达式作为回调
        std::cout << "您输入的数字是: " << value << std::endl;
    });
}
```
3. **抽象接口**（面向对象风格）：
```
// 回调接口
class ProgressCallback {
public:
    virtual void update(int percent) = 0;
};

// 使用回调的类
class FileDownloader {
public:
    void download(ProgressCallback* callback) {
        for (int i = 0; i <= 100; i += 10) {
            // 模拟下载进度
            callback->update(i);
        }
    }
};

// 回调实现
class DownloadProgress : public ProgressCallback {
public:
    void update(int percent) override {
        std::cout << "下载进度: " << percent << "%" << std::endl;
    }
};

int main() {
    FileDownloader downloader;
    DownloadProgress progress;
    downloader.download(&progress);
}
```
#### 场景
##### 1. 事件驱动编程

**场景**：GUI应用程序、游戏开发、用户交互 **作用**：响应外部事件（点击、键盘输入、定时器等） **示例**：

```
// 伪代码：GUI按钮点击回调
Button loginButton("登录");
loginButton.onClick([]() {
    std::string username = usernameField.getText();
    std::string password = passwordField.getText();
    authenticate(username, password);
});
```

##### 2. 异步操作完成通知

**场景**：网络请求、文件I/O、数据库操作 **作用**：在耗时操作完成时通知调用方 **示例**：
```
// 伪代码：异步文件读取
asyncReadFile("data.txt", [](const std::string& content, bool success) {
    if (success) {
        processContent(content);
    } else {
        showError("读取文件失败");
    }
});
// 此处代码继续执行，不阻塞
```
##### 3. 自定义算法行为

**场景**：排序、搜索、遍历算法 **作用**：允许调用方自定义算法行为 **示例**：

```
// 使用自定义比较回调排序
std::vector<Person> people = getPeople();

// 按年龄排序
std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
    return a.age < b.age;
});

// 按姓名排序
std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
    return a.name < b.name;
});
```

##### 4. 定时任务调度

**场景**：周期性任务、延迟执行 **作用**：在指定时间后执行操作 **示例**：
```
// 伪代码：定时器回调
Timer timer;
timer.setInterval(1000, []() { // 每秒执行一次
    updateClockDisplay();
});

timer.setTimeout(5000, []() { // 5秒后执行
    showNotification("操作超时");
});
```

##### 5. 状态变更通知

**场景**：游戏状态机、工作流引擎 **作用**：在对象状态改变时通知观察者 **示例**：
```
class GameCharacter {
    int health;
    std::vector<std::function<void(int)>> healthCallbacks;
    
public:
    void setHealth(int newHealth) {
        health = newHealth;
        // 通知所有注册的回调
        for (auto& cb : healthCallbacks) {
            cb(health);
        }
    }
    
    void onHealthChange(std::function<void(int)> callback) {
        healthCallbacks.push_back(callback);
    }
};

// 使用
Character player;
player.onHealthChange([](int health) {
    if (health <= 0) {
        playSound("death_sound.wav");
    } else if (health < 30) {
        showWarning("生命值过低!");
    }
});
```
##### 6. 插件系统与扩展点

**场景**：框架开发、应用程序扩展 **作用**：允许第三方扩展功能 **示例**：
```
// 图像处理框架中的滤镜扩展点
std::vector<FilterCallback> filters;

void registerFilter(FilterCallback filter) {
    filters.push_back(filter);
}

void applyFilters(Image& img) {
    for (auto& filter : filters) {
        filter(img); // 应用注册的滤镜
    }
}

// 第三方插件注册滤镜
void installSepiaFilter() {
    registerFilter([](Image& img) {
        // 实现棕褐色滤镜效果
    });
}
```

#### 回调函数的优缺点

##### 优点：

- **解耦**：调用方和回调方不需要直接依赖
- **灵活性**：可以在运行时改变行为
- **复用性**：通用代码可以与不同回调组合
- **异步支持**：适合非阻塞操作
- **可扩展性**：便于添加新功能而不修改现有代码

##### 缺点：

- **回调地狱**：多层嵌套回调降低可读性（解决方案：Promise/Future模式）
- **调试困难**：执行流程难以追踪
- **生命周期管理**：需要注意对象生命周期（尤其在C++中）
- **类型安全**：函数指针方式缺乏类型检查