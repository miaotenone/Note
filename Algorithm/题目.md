[2. 两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/)
递归--创建新节点
```
class Solution {
public:
    int carry = 0;
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if(carry==0&&l1==nullptr&&l2==nullptr){
            return nullptr;
        }
        int sum = carry;
        if(l1){
            sum += l1->val;
            l1 = l1->next;
        }
        if(l2){
            sum += l2->val;
            l2 = l2->next;
        }
        carry = sum/10;
        return new ListNode(sum%10,addTwoNumbers(l1,l2));
    }
};
```
递归--原地修改
```
class Solution {
public:
    int carry = 0;
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        if(l1==nullptr&&l2==nullptr){
            return carry?new ListNode(carry): nullptr;
        }
        if(!l1){
            swap(l1,l2);
        }
        int sum = carry + l1->val + (l2?l2->val:0);
        carry = sum/10;
        l1->val = sum%10;
        l1->next = addTwoNumbers(l1->next,(l2?l2->next:nullptr));
        return l1;
    }
};
```
迭代法创建新节点
```
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummyNode = new ListNode(0);
        ListNode* node = dummyNode;
        int carry = 0;
        while(l1||l2||carry){
            if(l1){
                carry += l1->val;
                l1 = l1->next;
            }
            if(l2){
                carry += l2->val;
                l2 = l2->next;
            }
            node->next = new ListNode(carry%10);
            carry = carry/10;
            node = node->next;
        }
        node = dummyNode->next;
        delete dummyNode;
        dummyNode = nullptr;
        return node;
    }
};
```

[4. 寻找两个正序数组的中位数 - 力扣（LeetCode）](https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/2950686/tu-jie-xun-xu-jian-jin-cong-shuang-zhi-z-p2gd/)

二分查找




[7. 整数反转 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-integer/solutions/211865/tu-jie-7-zheng-shu-fan-zhuan-by-wang_ni_ma/)
防止溢出的思路是 不能大于 INT32_MAX/10 或者 等于INT32_MAX/10&&大于INT32_MAX%10
```
int res = 0;
        int mainPNum = INT32_MAX/10;
        int remainPNum = INT32_MAX%10;
        int mainNNum = INT32_MIN/10;
        int remainNNum = INT32_MIN%10;
        while(x!=0){
            int tmp = x%10;
            if(res>mainPNum||(res==mainPNum&&tmp>remainPNum)){
                return 0;
            }
            if(res<mainNNum||(res==mainNNum&&tmp<remainNNum)){
                return 0;
            }
            res = res*10 + tmp;
            x= x/10;
        }
        return res;
```

[69. x 的平方根 - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/solutions/)
求平方根两种方法--二分法或者牛顿迭代

``` 
//牛顿迭代法
class Solution {
public:
    int mySqrt(int x) {
        if (x == 0) {
            return 0;
        }

        double C = x, x0 = x;
        while (true) {
            double xi = 0.5 * (x0 + C / x0);
            if (fabs(x0 - xi) < 1e-7) {
                break;
            }
            x0 = xi;
        }
        return int(x0);
    }
};
```
![[牛顿迭代介绍.png]]
![[牛顿迭代算法.png]]


```
class Solution {
public:
    int mySqrt(int x) {
        // 开区间 (left, right)
        int left = 0, right = min(x, 46340) + 1;
        while (left + 1 < right) { // 开区间不为空
            // 循环不变量：left^2 <= x
            // 循环不变量：right^2 > x
            int m = (left + right) / 2;
            (m * m <= x ? left : right) = m;
        }
        // 循环结束时 left+1 == right
        // 此时 left^2 <= x 且 right^2 > x
        // 所以 left 最大的满足 m^2 <= x 的数
        return left;
    }
};
```

[【LeetCode - 157】用 Read4 读取 N 个字符_157 用 read4 读取 n 个字符 题目-CSDN博客](https://blog.csdn.net/qq_29051413/article/details/108709170)




[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/)

在一个数组里，有一个元素的数量大于[n/2],找出这个元素。要求O(n)的时间复杂度和O(1)的空间复杂度。
需要用到Boyer-Moore 投票算法，如果我们把众数记为 +1，把其他数记为 −1，将它们全部加起来，显然和大于 `0`，从结果本身我们可以看出众数比其他数多。
算法步骤：
我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；
我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：
如果 x 与 candidate 相等，那么计数器 count 的值增加 1；
如果 x 与 candidate 不等，那么计数器 count 的值减少 1。
在遍历完成后，candidate 即为整个数组的众数。





[258. 各位相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-digits/)


[263. 丑数 - 力扣（LeetCode）](https://leetcode.cn/problems/ugly-number/solutions/3007807/li-yong-wei-yun-suan-you-hua-pythonjavac-nlqr/)


[268. 丢失的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/missing-number/solutions/1085105/diu-shi-de-shu-zi-by-leetcode-solution-naow/)


[290. 单词规律 - 力扣（LeetCode）](https://leetcode.cn/problems/word-pattern/solutions/)


[73. 矩阵置零 - 力扣（LeetCode）](https://leetcode.cn/problems/set-matrix-zeroes/solutions/670278/xiang-jie-fen-san-bu-de-o1-kong-jian-jie-dbxd/?envType=study-plan-v2&envId=top-100-liked)


[31. 下一个排列 - 力扣（LeetCode）](https://leetcode.cn/problems/next-permutation/solutions/3621022/jiao-ni-cong-ling-kai-shi-si-kao-zhe-ti-9qfrq/?envType=study-plan-v2&envId=top-100-liked)
未完成

[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/solutions/11472/product-of-array-except-self-shang-san-jiao-xia-sa/?envType=study-plan-v2&envId=top-100-liked)
上三角和下三角相乘

[41. 缺失的第一个正数 - 力扣（LeetCode）](https://leetcode.cn/problems/first-missing-positive/submissions/637414759/?envType=study-plan-v2&envId=top-100-liked)
坐座位，如果在1-n内，判断是否在应该的位置上，如果不在的话就和对应的位置换位置
最后循环判断哪个不在正确的位置就是答案
如果没有，就返回n+1


[138. 随机链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/copy-list-with-random-pointer/solutions/2361362/138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-b-6jeo/?envType=study-plan-v2&envId=top-100-liked)
构建哈希映射 源节点和新节点之间的关系 然后直接遍历就可以
第二种---复制各节点，构建拼接链表---构建新节点random指向---拆分

[148. 排序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-list/solutions/2993518/liang-chong-fang-fa-fen-zhi-die-dai-mo-k-caei/?envType=study-plan-v2&envId=top-100-liked)
方法一：
1. 找到**链表的中间结点** head2​ 的**前一个节点**，并断开 head2​ 与其前一个节点的连接。这样我们就把原链表均分成了两段更短的链表
2. 分治，递归调用 sortList，分别排序 head（只有前一半）和 head2​。
3. 排序后，我们得到了两个有序链表，那么**合并两个有序链表**，得到排序后的链表，返回链表头节点。

[199. 二叉树的右视图 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-right-side-view/solutions/2015061/ru-he-ling-huo-yun-yong-di-gui-lai-kan-s-r1nc/?envType=study-plan-v2&envId=top-100-liked)
层序遍历--找到每一层最后一个
深度搜索 --- 先递归右子树，再遍历左子树，左子树刚突破一层的就是答案
```
class Solution {
    vector<int> ans;
    void dfs(TreeNode* node,int depth){
        if(node==nullptr){
            return;
        }
        if(depth==ans.size()){
            ans.push_back(node->val);
        }
        dfs(node->right,depth+1);
        dfs(node->left,depth+1);
    }
public:
    vector<int> rightSideView(TreeNode* root) {
        ans.clear();
        dfs(root,0);
        return ans;
    }
};
```

[23. 合并 K 个升序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-k-sorted-lists/solutions/2384305/liang-chong-fang-fa-zui-xiao-dui-fen-zhi-zbzx/?envType=study-plan-v2&envId=top-100-liked)

分治算法---迭代或者递归
```
class Solution {
     ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy{}; // 用哨兵节点简化代码逻辑
        auto cur = &dummy; // cur 指向新链表的末尾
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1; // 把 list1 加到新链表中
                list1 = list1->next;
            } else { // 注：相等的情况加哪个节点都是可以的
                cur->next = list2; // 把 list2 加到新链表中
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2; // 拼接剩余链表
        return dummy.next;
    }
     ListNode* mergeKLists(vector<ListNode*>& lists, int i, int j) {
        int m = j - i;
        if (m == 0) {
            return nullptr; // 注意输入的 lists 可能是空的
        }
        if (m == 1) {
            return lists[i]; // 无需合并，直接返回
        }
        auto left = mergeKLists(lists, i, i + m / 2); // 合并左半部分
        auto right = mergeKLists(lists, i + m / 2, j); // 合并右半部分
        return mergeTwoLists(left, right); // 最后把左半和右半合并
    }
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return mergeKLists(lists, 0, lists.size());
    }
};
```
迭代法
两两合并：把 lists[0] 和 lists[1] 合并，合并后的链表保存在 lists[0] 中；把 lists[2] 和 lists[3] 合并，合并后的链表保存在 lists[2] 中；依此类推。
四四合并：把 lists[0] 和 lists[2] 合并（相当于合并前四条链表），合并后的链表保存在 lists[0] 中；把 lists[4] 和 lists[6] 合并，合并后的链表保存在 lists[4] 中；依此类推。
八八合并：把 lists[0] 和 lists[4] 合并（相当于合并前八条链表），合并后的链表保存在 lists[0] 中；把 lists[8] 和 lists[12] 合并，合并后的链表保存在 lists[8] 中；依此类推。
依此类推，直到所有链表都合并到 lists[0] 中。最后返回 lists[0]。
```
class Solution {
    // 21. 合并两个有序链表
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode dummy{}; // 用哨兵节点简化代码逻辑
        auto cur = &dummy; // cur 指向新链表的末尾
        while (list1 && list2) {
            if (list1->val < list2->val) {
                cur->next = list1; // 把 list1 加到新链表中
                list1 = list1->next;
            } else { // 注：相等的情况加哪个节点都是可以的
                cur->next = list2; // 把 list2 加到新链表中
                list2 = list2->next;
            }
            cur = cur->next;
        }
        cur->next = list1 ? list1 : list2; // 拼接剩余链表
        return dummy.next;
    }

public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        int m = lists.size();
        if (m == 0) {
            return nullptr;
        }
        for (int step = 1; step < m; step *= 2) {
            for (int i = 0; i < m - step; i += step * 2) {
                lists[i] = mergeTwoLists(lists[i], lists[i + step]);
            }
        }
        return lists[0];
    }
};
```

最小堆
创建一个自定义的优先级队列，初始先把所有vector的节点放进去，然后弹出节点，并把这个节点的下一个加入进去（如果不为空）
```
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
         auto cmp = [](const ListNode* a, const ListNode* b) {
            return a->val > b->val; // 最小堆
        };
        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq;
        for (auto head : lists) {
            if (head) {
                pq.push(head); // 把所有非空链表的头节点入堆
            }
        }

        ListNode dummyNode{};
        ListNode* cur = &dummyNode;
        while(!pq.empty()){
            auto node = pq.top(); // 剩余节点中的最小节点
            pq.pop();
            if (node->next) { // 下一个节点不为空
                pq.push(node->next); // 下一个节点有可能是最小节点，入堆
            }
            cur->next = node; // 把 node 添加到新链表的末尾
            cur = cur->next; // 准备合并下一个节点
        }
        return dummyNode.next;
    }
};
```

[114. 二叉树展开为链表 - 力扣（LeetCode）](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&envId=top-100-liked)
头插法--反过来遍历（右-左-中）记录遍历的前一个节点，设置left=nullptr，right=前一个节点
分治法--单独思考一个节点（假设左右节点都在）---1、左节点的右子节点是root的右节点---2、root的右节点是左节点---左子节点设为空
```
class Solution {
    TreeNode* dfs(TreeNode* root) {
        if (root == nullptr) {  // 空节点直接返回
            return nullptr;
        }
        // 递归展开左右子树，获取尾节点
        TreeNode* left_tail = dfs(root->left);
        TreeNode* right_tail = dfs(root->right);

        // 关键拼接逻辑（仅当左子树存在时操作）
        if (left_tail) {
            left_tail->right = root->right; // 左子树尾节点→右子树头节点
            root->right = root->left;       // 当前节点→原左子树头节点
            root->left = nullptr;           // 断开左指针（链表要求）
        }

        // 返回当前子树尾节点（优先级：右子树尾 > 左子树尾 > 当前节点）
        return right_tail ? right_tail : (left_tail ? left_tail : root);
    }

public:
    void flatten(TreeNode* root) {
        dfs(root);  // 触发递归展开
    }
};
```

[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/)
前缀和+哈希表 前缀和的定义是`s[0]=0, s[i+1]=nums[0]+nums[1]+⋯+nums[i]`。
