##### 定义
KMP算法的核心是利用**匹配失败后的信息**，尽量减少模式串与主串的匹配次数，以达到快速匹配的目的。它通过一个**next函数**实现，该函数包含了模式串的局部匹配信息
**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**
##### 条件
连续匹配---在s中寻找t是否存在
##### 应用场景
KMP算法广泛应用于字符串匹配、文本编辑、生物信息学等领域，特别是在需要快速查找一个字符串是否包含另一个字符串的场合。
##### next数组
**前缀表**：记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。
**作用**：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。
**最长相等前后缀**：前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。
![[Pasted image 20250422100843.png]]
如果在5的位置不匹配，就会到红箭头指向的位置。下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为**找到了最长相等的前缀和后缀**，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。
**next数组**：就是前缀表或者统一减一
##### 算法步骤
1. **预处理**：计算模式串的next数组，该数组表示模式串每个位置之前的字符串的前缀和后缀公共部分的最大长度（不包括字符串本身）。
2. **匹配**：在匹配过程中，当遇到不匹配的字符时，根据next数组的值将模式串向右移动，移动的距离为已匹配长度减去最大公共长度，然后继续比较下一个位置

##### 模板
```
//计算next数组和模式匹配的思路是一样的
//计算next数组 全部-1
void builtNext(vector<int>& next,string& s)
{
	//初始化 i--后缀末尾 j--前缀末尾
	int j = -1;
	next[0] = -1;
	for (int i = 1; i < s.size(); i++) {
		while (j >= 0 && s[j + 1] != s[i]) {
			j = next[j];
		}
		if (s[j + 1] == s[i]) { j++; }
		next[i] = j;
	}
}
//匹配
int j = -1; // 因为next数组里记录的起始位置为-1
for (int i = 0; i < s.size(); i++) { // 注意i就从0开始
    while(j >= 0 && s[i] != t[j + 1]) { // 不匹配
        j = next[j]; // j 寻找之前匹配的位置
    }
    if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动
        j++; // i的增加在for循环里
    }
    if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t
        return (i - t.size() + 1);
    }
}
```