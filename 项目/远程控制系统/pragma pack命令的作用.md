`#pragma pack` 是 C/C++ 中用于控制结构体（struct）或联合体（union）内存对齐方式的预处理指令。它的作用是告诉编译器按照指定的字节对齐方式对数据进行内存布局。以下是具体解释：
### **1. `#pragma pack(push)`**

- **作用**：将当前的对齐方式（即编译器的默认对齐值）压入“编译器的内部栈”中，保存当前的对齐状态。
    
- **用途**：通常与 `#pragma pack(pop)` 配合使用，用于临时修改对齐方式后恢复原有对齐方式。
    

---

### **2. `#pragma pack(1)`**

- **作用**：设置结构体的对齐方式为 **1 字节对齐**（即“无对齐”），强制编译器不对结构体成员进行内存填充（padding），所有成员紧密排列。
    
- **效果**：结构体的总大小等于所有成员大小的总和，但可能因未对齐导致访问性能下降（某些硬件平台可能不支持未对齐访问，甚至崩溃）。
    
- **示例**
```
    
    struct Example {
        char a;    // 1 byte
        int b;     // 4 bytes
        short c;   // 2 bytes
    };
```
    
    - 默认对齐（如 4 字节）：结构体大小可能为 12 字节（包含填充）。
        
    - 使用 `#pragma pack(1)` 后：结构体大小为 `1 + 4 + 2 = 7` 字节。
        

---

### **3. `#pragma pack(pop)`**

- **作用**：从“编译器的内部栈”中弹出最近保存的对齐方式，恢复之前的对齐状态。
    
- **用途**：在临时修改对齐方式后（例如为了兼容特定硬件或协议），恢复默认对齐方式，避免影响后续代码。